KWS = { # keywords forwarded to procs
  "typeof" => ->(x : String, y : Int32) { _typeof_(x,y) }, 
  "print" => ->(x : String, y : Int32) { _print_ x },
  "puts" => ->(x : String, y : Int32) { _puts_ x  },
  "p" => ->(x : String, y : Int32) { _p_ x },
  "eval" => ->(x : String, y : Int32) { eval x; return "",0 },
  "ceval" => ->(x : String, y : Int32) { ceval x; return "",0 },
  "after" => ->(x : String, y : Int32) { _after_(x, y); return "",0 },
  "def" => ->(x : String, y : Int32) { _def_(x, y); return "",0 },
  "return" => ->(x : String, y : Int32) { _return_(x, y); return "",0 },
  "+" => ->(x : String, y : Int32) {  r = plus(x, y); return r, 0 },
  "-" => ->(x : String, y : Int32) { r = minus(x, y); return r, 0 },
  "*" => ->(x : String, y : Int32) { r = mul(x, y); return r, 0 },
  "/" => ->(x : String, y : Int32) { r = div(x, y); return r, 0 },
  "inc" => ->(x : String, y : Int32) { inc(x, y) },
  "dec"=> ->(x : String, y : Int32) { dec(x, y) },
  "<" => ->(x : String, y : Int32) { r = Code._lower_(x, y); return "",r },
  ">" => ->(x : String, y : Int32) { r =_higher_(x, y); return "",r },
  "if" => ->(x : String, y : Int32) { r = Code._if_(x, y); return "",r },    #if1
  "eq" => ->(x : String, y : Int32) { r = Code._if_(x, y); return "",r },    #if2
  "while" => ->(x : String, y : Int32) { Code._while_(x, y); return "",0 },
  "end" => ->(x : String, y : Int32) { Code._end_; return "",0 },
  "every" => ->(x : String, y : Int32) { t = Timer.new; r = t.start_timer(x,y); return "", r },
  "ls" => ->(x : String, y : Int32) { ls(x,y); return "",0 },
  "vars" => ->(x : String, y : Int32) { ls("vars",1); return "",0 },
  "let" => ->(x : String, y : Int32) { let(x,y); return "",0 },
  "=" => ->(x : String, y : Int32) { let(x,y); return "nil",0 },
  "delete" => ->(x : String, y : Int32) { _delete_ x; return "",0 },
  "clear" => ->(x : String, y : Int32) { clear x; return "",0 },
  "!" => ->(x : String, y : Int32) { system(x); return "",0 },
  "now" => ->(x : String, y : Int32) { return Time.local.to_s("%H:%M:%S.%6N"),0 },
  "date" => ->(x : String, y : Int32) { return Time.local.to_s("%Y-%m-%d"),0 },
  "test" => ->(x : String, y : Int32) { procloop; return "",0 },
  "sleep" => ->(x : String, y : Int32) { sleep(x.to_f); return "",0 },
  "pass" => ->(x : String, y : Int32) { pass; return "",0 },
  "cls" => ->(x : String, y : Int32) { print "\33c\e[3J"; return "",0 },
  "load" => ->(x : String, y : Int32) { Code.load x; return "",0 },
  "run" =>  ->(x : String, y : Int32) { Code.current_line = 0; CONTEXTS.clear; Code.run (x); return "",0 },
  "split_run" => ->(x : String, y : Int32) { Code.split_run; return "",0 },
  "help" => ->(x : String, y : Int32) { help(x); return "",0 },
  "debug" => ->(x : String, y : Int32) { Code.debug = !Code.debug; return Code.debug.to_s,0 },
  "singlestep" => ->(x : String, y : Int32) { VARS["singlestep"] = !VARS["singlestep"]; return VARS["singlestep"].to_s,0 },
  "inject" => ->(x : String, y : Int32) { Code.inject = !Code.inject; return Code.inject.to_s,0 },
  "system" => ->(x : String, y : Int32) { _system_(x); },
  "exit" => ->(x : String, y : Int32) { exit(0); return "",0 },
  "Array" => ->(x : String, y : Int32) { _array_(x,y); return "",0 },
  "append" =>  ->(x : String, y : Int32) { _append_(x,y); return "",0 },
  "list" => ->(x : String, y : Int32) { Code.list(x); return "",0 },
  "log"  => ->(x : String, y : Int32) { Tlog.info(check_args(x)) ; return "",0 },
  "clear_log" => ->(x : String, y : Int32) { Tlog.clearlog() ; return "",0 },
  "insert_line" => ->(x : String, y : Int32) { Code.insert(x,y); return "",0 },
  "write_line" => ->(x : String, y : Int32) { Code.write(x,y); return "",0 },
  "delete_line" => ->(x : String, y : Int32) { Code.delete(x); return "",0 },
  "open_ipc" => ->(x : String, y : Int32) { open_ipc(); return "",0 },
  "send_ipc" => ->(x : String, y : Int32) { send_ipc(x); return "",0 },
  "receive_ipc" => ->(x : String, y : Int32) { receive_ipc() },
  "send_receive_ipc"  => ->(x : String, y : Int32) { send_receive_ipc(x) },
  "show_ipc_results" => ->(x : String, y : Int32) { show_ipc_results(x); return "",0 },
  "read_int_var" => ->(x : String,y : Int32) { return "",Code.functions[Code.cfu][x] },
}